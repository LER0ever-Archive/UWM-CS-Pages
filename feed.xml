<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">
  <channel>
    <title>L.E.R Space</title>
    <link>https://pages.cs.wisc.edu/~rong</link>
    <description>L.E.R Space, a magical personal website by Yi Rong</description>
    <managingEditor> (L.E.R)</managingEditor>
    <pubDate>Tue, 13 Sep 2016 22:08:06 -0500</pubDate>
    <item>
      <title>HydroDev, Powerful DevPack</title>
      <link>http://pages.cs.wisc.edu/~rong/~rong/2016/9/3/lumos.html</link>
      <description>&lt;h3 id=&#34;about&#34;&gt;About&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;HydroDev is a full-featured developer&amp;rsquo;s pack, including a build system, a deployer, a tester and a bunch of extensible functions.&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;get-started&#34;&gt;Get Started&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Request a binary by &lt;a href=&#34;http://yirong.ml/sn&#34;&gt;contacting me&lt;/a&gt;.&lt;/p&gt;&#xA;</description>
      <author>L.E.R</author>
      <pubDate>Sat, 03 Sep 2016 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>About this New Site</title>
      <link>http://pages.cs.wisc.edu/~rong/~rong/2016/8/5/welcome.html</link>
      <description>&lt;h2 id=&#34;welcome-to-this-new-website&#34;&gt;Welcome to this new website&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;I&amp;rsquo;ve been working on the &amp;ldquo;Lumos static site generator&amp;rdquo; for a while, aiming to create a full featured static site generator that can replace most of the WordPress features.&lt;br /&gt;&#xA;This website is the very first static site generated by Lumos that uses a theme modified from wordpress to fit Lumos. See &lt;a href=&#34;https://github.com/DuenaStudio/DuenaTheme&#34;&gt;DuenaStudio/DuenaTheme&lt;/a&gt; for the original one.&lt;br /&gt;&#xA;If you need something from my wordpress blog, please visit&lt;a href=&#34;https://etasry.ml&#34;&gt;https://etasry.ml&lt;/a&gt;&#xA;Chinese visitors may suffer from low-speed connection to Google Fonts.&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;i18n&#34;&gt;I18n&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;yirong.ml is in English&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;rongyi.ml is in Chinese&lt;br /&gt;&#xA;&lt;br /&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;This site (yirong.ml) is ready for almost all visitor accross the globe. It uses services accessable to all including [Google Fonts, Google Analytics, imgur, Disqus] and is hosted on Github Pages, while the Chinese site uses many local services, like [useso font, baidu analytics, tietuku, duoshuo]. So rongyi.ml is likely to have slow loading speed outside mainland China.&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;You can double tap &amp;ldquo;Alt&amp;rdquo; to search contents of this blog&lt;/li&gt;&#xA;&lt;li&gt;The post permalink structure is &amp;ldquo;/year/month/day/slug.html&amp;rdquo;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
      <author>L.E.R</author>
      <pubDate>Fri, 05 Aug 2016 12:20:20 +0000</pubDate>
    </item>
    <item>
      <title>Lumos Static Site Generator</title>
      <link>http://pages.cs.wisc.edu/~rong/~rong/2016/8/5/lumos.html</link>
      <description>&lt;p&gt;For now, it&amp;rsquo;s still a propriatary project on Github, and I don&amp;rsquo;t think anyone would ever user it except me. So I&amp;rsquo;ll leave it close-source. (You can commment below if you want the code)&#xA;&lt;strong&gt;The README file on Github (including copyright info)：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;lumos&#34;&gt;Lumos&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/license-AGPL%20V3-yellowgreen.svg?style=flat-square&#34; alt=&#34;license&#34; /&gt;&#xA;&lt;img src=&#34;https://img.shields.io/badge/LER0ever-Project%20Lumos-blue.svg?style=flat-square&#34; alt=&#34;israfil&#34; /&gt;&lt;br /&gt;&#xA;Full Featured Static Site Generator&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;about&#34;&gt;About&lt;/h1&gt;&#xA;&#xA;&lt;h3 id=&#34;what-it-is&#34;&gt;What it is&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;A static site generator, aiming to support most features of WordPress and replace my old WP Blog.&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;why-there-re-dozens-of-hexo-s&#34;&gt;Why? There&amp;rsquo;re dozens of Hexo-s&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;I created this project mainly because I can&amp;rsquo;t bear the slow loading speed of WordPress while there isn&amp;rsquo;t a full alternative static site generator. It&amp;rsquo;s probably just my personal project, but everyone can use it for free under the term of AGPL. Issues are also welcomed.&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;features&#34;&gt;Features&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[x] Categories!&lt;/li&gt;&#xA;&lt;li&gt;[x] Side Widgets!&lt;/li&gt;&#xA;&lt;li&gt;[x] TagCloud! (in my theme)&lt;/li&gt;&#xA;&lt;li&gt;[x] FrontPage and PostPage support&lt;/li&gt;&#xA;&lt;li&gt;[x] Full site minify !&lt;/li&gt;&#xA;&lt;li&gt;[x] Post Counts for specific Cat or Tag&lt;/li&gt;&#xA;&lt;li&gt;[x] Recent Posts&lt;/li&gt;&#xA;&lt;li&gt;[x] Cross All Platforms and Architectures&lt;/li&gt;&#xA;&lt;li&gt;[x] Search !&lt;/li&gt;&#xA;&lt;li&gt;[x] Other awesome features from &lt;a href=&#34;https://github.com/LER0ever/Lumos/blob/master/README.md#license&#34;&gt;PUGO 0.10&lt;/a&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[x] Auto Deploy to git, aws, ftp, cdn.&lt;/li&gt;&#xA;&lt;li&gt;[x] Sitemap and Feed generation&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;[x] Other awesome features from Deuna&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[x] Fully responsive&lt;/li&gt;&#xA;&lt;li&gt;[x] Flat and modern design&lt;/li&gt;&#xA;&lt;li&gt;[x] Social Info&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;[ ] Customized Permalink&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3 id=&#34;screenshots&#34;&gt;Screenshots&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Since my goal is to replace my wp site, here are the current comparison between the site generated by Lumos and the original WordPress site (both in Duena Theme).&lt;/p&gt;&#xA;&#xA;&lt;h4 id=&#34;lumos-site&#34;&gt;Lumos Site:&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://i4.piimg.com/7134/6551e2494d701e59.png&#34; alt=&#34;lumospng&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4 id=&#34;wordpress-site&#34;&gt;WordPress Site:&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://i4.piimg.com/7134/8c384b1fc743e4ff.png&#34; alt=&#34;wppng&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;compile&#34;&gt;Compile&lt;/h1&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Requires Go 1.5+ and Glide package manager&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;Install the required packages using &lt;code&gt;glide install&lt;/code&gt; then,&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;If you are on *nix, then &lt;code&gt;build-all.sh&lt;/code&gt; will help you generate binaries for all platforms(Win, Linux, Darwin, Freebsd) with all archs(386, amd64, arm)&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;Else &lt;code&gt;go build&lt;/code&gt; will always produce the executable.&lt;br /&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h1 id=&#34;license&#34;&gt;License&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Lumos is licensed under AGPL V3 (see &lt;a href=&#34;https://github.com/LER0ever/Lumos/blob/master/doc/LICENSE&#34;&gt;doc/LICENSE&lt;/a&gt;).&lt;/strong&gt; However, the website generated does not apply this license, meaning you can freely modify the output HTMLs.&lt;br /&gt;&#xA;This project contains part of code from &lt;a href=&#34;https://github.com/go-xiaohei/pugo/tree/0.10.0&#34;&gt;Pugo 0.10.0&lt;/a&gt;(MIT License), see &lt;a href=&#34;https://github.com/LER0ever/Lumos/blob/master/doc/PUGO.LICENSE&#34;&gt;doc/PUGO.LICENSE&lt;/a&gt; for details&lt;/p&gt;&#xA;</description>
      <author>L.E.R</author>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>AlphaGo Tech 2 - Deep Learning</title>
      <link>http://pages.cs.wisc.edu/~rong/~rong/2016/3/11/alphago-intro-dl.html</link>
      <description>&lt;h5 id=&#34;sorry-this-post-is-still-under-translation-to-english&#34;&gt;Sorry, this post is still under translation to English&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;上一篇传送门：&lt;a href=&#34;/2016/3/10/alphago-intro-mcts.html&#34;&gt;AlphaGo核心技术之一，蒙特卡洛树搜索&lt;/a&gt;&#xA;&lt;h3&gt;科普&lt;/h3&gt;&#xA;&lt;h5&gt;深度学习&lt;/h5&gt;&#xA;深度学习指多层的人工神经网络及其学习方法。与普通的人工神经网络不同的是，深度学习模拟人脑进行分析、学习的能力更强。一般来讲，神经网络把一大批矩阵数字作文输入，然后通过非线性激活函数(如Sigmoid())来取权重，再产生一个集合作为输出。人类的生物大脑有类似的工作机理，外部的信号经过初步处理后，交给多层的神经组织形成的神经网络处理，不同的是你的大脑里没有任何中间的矩阵数字。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最早的神经网络算法Back Propagation在上世纪80年代就有了，之所以机器学习到现在才开始流行，是因为人工神经网络的训练需要海量的数据，Google写的卷积神经网络(Convolutional Neural Networks)在没有外界指令的自发条件下，通过1.6万块CPU，看了YouTube上1000万段视频，才有了“猫”这个概念。如今倡导大数据的时代，机器学习算法自然有足够的数据去学习，也就导致了其蓬勃发展。&lt;/p&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;p&gt;&lt;h3&gt;AlphaGo使用的技术&lt;/h3&gt;&#xA;AlphaGo相当于用了两个“大脑”, Policy Network 和 Value Network。每走一步棋都会参考两个大脑返回的结果（快速走子除外，采用Fast Rollout），相当于两个大脑合作选择如何落子。两个大脑都是用多层神经网络构成的，可以理解成和Google 图片搜索结构差不多的一个东西。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img class=&#34;alignnone&#34; src=&#34;http://i.imgur.com/wwoRiKZ.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先AlphaGo通过多层启发式二维过滤器处理围棋棋盘定位，过滤后的结果经过13层全连接神经网络处理，包括逻辑推理和分类。&#xA;&lt;h5&gt;Policy Network&lt;/h5&gt;&#xA;&lt;img src=&#34;http://i.imgur.com/Ol5XkCw.jpg&#34; alt=&#34;数字大的表示人类选手最有可能下的地方&#34; /&gt; 数字大的表示人类选手最有可能下的地方&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Policy Network帮助AlphaGo进行落子选择，一部分采用的是监督式学习(Supervised Learning)的策略网络，可以找到棋盘上合法的最佳下一步。原理就是预测每一个可落子点的最佳概率，所以最前面猜测的就是概率最高的。另一部分落子选择用的是强化学习的策略网络，通过互联网上数千万的模拟棋局训练，把每一个模拟棋局下到底，训练最可能赢的下法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是Policy Network有个明显的缺陷，它是根据当前的棋盘和之前落子前的棋盘判断当前一步最优落子点，所以它不会去模拟未来任何一个棋子会怎么样。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;除开正常落子选择，AlphaGo的团队还设计了一个FastRollout，普通的落子选择需要看19*19的整个棋盘，而FastRollout只看对手上一步棋和这一步棋之间的矩形来作出快速落子决定，数据显示下子比普通版快1000倍。&#xA;&lt;h5&gt;Value Network&lt;/h5&gt;&#xA;Value Network相当于一个棋局评估器(Position Evaluator)。由于Policy Network只根据当前状况作最优选择，所以需要一个系统来预测未来棋子走向，Value Network预测棋手每一个落子点的赢棋可能，通过整体的局面来辅助Policy Network的落子选择器。不过这个只是大概的判断，不是精确到0.1%胜率的那种，只是帮助落子选择更好的阅读棋盘。分析完大量的落棋可能后，Value Network分类出未来局面潜在的有利和不利, AlphaGo能够判断能否通过特殊变种去深入阅读，如果Value Network估计下来特殊变种不行，那么AlphaGo跳过这条线上任何更多落子的阅读。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/gTYDmF8.jpg&#34; alt=&#34;图中深蓝色的表示更有利的落子点&#34; /&gt; 图中深蓝色的表示更有利的落子点&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个评估器也经过了百万棋局的训练，DeepMind团队通过强大的落子选择器挑选随即样本创造了这些局面作训练数据，AI不仅可以被训练，也可以用来创造大量高效的数据集。AlphaGo的评估器基本可以在任意棋盘上评估双方胜利的可能。&#xA;&lt;h5&gt;最终决策&lt;/h5&gt;&#xA;单有两个深度学习的神经网络还不能帮助AlphaGo选择，DeepMind采用了很常见的MCTS作搜索树，用两个强大的大脑指引蒙特卡洛树搜索，使需要的搜索量降到了同效最低。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有关蒙特卡洛树搜索：&lt;a href=&#34;/2016/3/10/alphago-intro-mcts.html&#34; target=&#34;_blank&#34;&gt;AlphaGo核心技术之一，蒙特卡洛树搜索&lt;/a&gt;&#xA;&lt;h5&gt;弱点&lt;/h5&gt;&#xA;AlphaGo的弱点可能就是在全局考虑上，因为它是通过类似于5*5的小方格过滤棋盘来降低运算复杂度，所以整体战略的把握和调度肯定比不过围棋专业选手，但是它局部的布局基本是无敌的。所以想赢AlphaGo，你需要有世界一流的水平+前半句压倒性优势+创造大局陷阱。&lt;del&gt;搞得好像我会下围棋一样&lt;/del&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Reference：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;田渊栋博士的关于Facebook DarkForest的论文。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图片源于网络，如有侵权请第一时间联系我删除。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&#xA;</description>
      <pubDate>Fri, 11 Mar 2016 12:20:20 +0000</pubDate>
    </item>
    <item>
      <title>HHVM+MariaDB make PHP faster</title>
      <link>http://pages.cs.wisc.edu/~rong/~rong/2016/3/11/hhcm-mariadb-acc-php.html</link>
      <description>&lt;h4 id=&#34;this-post-is-still-under-translation-to-english&#34;&gt;This post is still under translation to English&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;HHVM是Facebook开源的PHP、Hack执行引擎，因为Facebook大多数的网页都是用PHP写的（包括Mark Zuckerburg在宿舍写的那部分），而PHP官方的zend又是效率极低。HHVM的Benchmark显示其效率比现在广泛使用的PHP5.x高5~10倍。搭配mariadb和nginx这两个轻量级的服务器软件，PHP网页的执行效率可能是用LAMP(Linux Apache2 MySQL PHP)搭建的网页高2~3倍，具体参照本网站的加载速度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以下是教程&lt;/p&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;p&gt;默认安装了Ubuntu 14.04LTS或以上版本，如果没有的话不保证成功，自行替换命令或Docker部署ubuntu镜像&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先安装Nginx，&#xA;&lt;pre class=&#34;lang:default decode:true &#34;&gt;sudo apt-get update&#xA;sudo apt-get install nginx&#xA;service nginx restart&lt;/pre&gt;&#xA;至此，访问你的网站，如etasry.ml，将会看到&#xA;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&#xA;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For online documentation and support please refer to &lt;a href=&#34;http://nginx.org/&#34;&gt;nginx.org&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Please use the &lt;tt&gt;reportbug&lt;/tt&gt; tool to report bugs in the nginx package with Debian. However, check &lt;a href=&#34;http://bugs.debian.org/cgi-bin/pkgreport.cgi?ordering=normal;archive=0;src=nginx;repeatmerged=0&#34;&gt;existing bug reports&lt;/a&gt; before reporting a new bug.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后安装HipHop Virtual Machine&#xA;&lt;pre class=&#34;lang:default decode:true &#34;&gt;sudo apt-get install autoconf automake binutils-dev build-essential cmake g++ gawk git&#xA;  libboost-dev libboost-filesystem-dev libboost-program-options-dev libboost-regex-dev&#xA;  libboost-system-dev libboost-thread-dev libboost-context-dev libbz2-dev libc-client-dev libldap2-dev&#xA;  libc-client2007e-dev libcap-dev libcurl4-openssl-dev libdwarf-dev libelf-dev&#xA;  libexpat-dev libgd2-xpm-dev libgoogle-glog-dev libgoogle-perftools-dev libicu-dev&#xA;  libjemalloc-dev libmcrypt-dev libmemcached-dev libmysqlclient-dev libncurses-dev&#xA;  libonig-dev libpcre3-dev libreadline-dev libtbb-dev libtool libxml2-dev zlib1g-dev&#xA;  libevent-dev libmagickwand-dev libinotifytools0-dev libiconv-hook-dev libedit-dev&#xA;  libiberty-dev libxslt1-dev ocaml-native-compilers libsqlite3-dev libyaml-dev libgmp3-dev&#xA;  gperf libkrb5-dev libnotify-dev&lt;/pre&gt;&#xA;安装完所有依赖项后，克隆源代码到本地&#xA;&lt;pre class=&#34;lang:default decode:true &#34;&gt;git clone git://github.com/facebook/hhvm.git --depth=1&#xA;cd hhvm&#xA;git submodule update --init --recursive&lt;/pre&gt;&#xA;编译并安装，替换-J后面的数字为你的CPU数量&#xA;&lt;pre class=&#34;lang:default decode:true &#34;&gt;cmake -DMYSQL_UNIX_SOCK_ADDR=/var/run/mysqld/mysqld.sock .&#xA;make -j [number_of_processor_cores] # eg. make -j 4&#xA;sudo make install&lt;/pre&gt;&#xA;二进制文件在/usr/local/bin/hhvm&lt;/p&gt;&#xA;&#xA;&lt;p&gt;随后执行/etc/hhvm/install-fastcgi.sh自动配置nginx，完成后你的nginx就会将PHP文件交给HHVM处理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写个简单的脚本测试一下：&#xA;&lt;pre class=&#34;lang:default decode:true &#34;&gt;&amp;lt;?php&#xA;phpinfo();&#xA;?&amp;gt;&lt;/pre&gt;&#xA;访问后如果你的HHVM执行这段代码的话应该返回HHVM Version 3.12.1&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然而WordPress是不可以直接运行的，Nginx不负责解析.htaccess文件，所以Permalinks全部会挂，显示404或者403。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以下分享一个我的WordPress W3TotalCache的Nginx.conf，仅供语法参考&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;# BEGIN W3TC Page Cache cache&#xA;location ~ /wp-content/cache/page_enhanced.*html$ {&#xA;    add_header Vary &amp;quot;Accept-Encoding, Cookie&amp;quot;;&#xA;}&#xA;location ~ /wp-content/cache/page_enhanced.*gzip$ {&#xA;    gzip off;&#xA;    types {}&#xA;    default_type text/html;&#xA;    add_header Vary &amp;quot;Accept-Encoding, Cookie&amp;quot;;&#xA;    add_header Content-Encoding gzip;&#xA;}&#xA;# END W3TC Page Cache cache&#xA;# BEGIN W3TC Browser Cache&#xA;gzip on;&#xA;gzip_types text/css text/x-component application/x-javascript application/javascript text/javascript text/x-js text/richtext image/svg+xml text/plain text/xsd text/xsl text/xml image/x-icon;&#xA;# END W3TC Browser Cache&#xA;# BEGIN W3TC Page Cache core&#xA;set $w3tc_rewrite 1;&#xA;if ($request_method = POST) {&#xA;    set $w3tc_rewrite 0;&#xA;}&#xA;if ($query_string != &amp;quot;&amp;quot;) {&#xA;    set $w3tc_rewrite 0;&#xA;}&#xA;if ($http_cookie ~* &amp;quot;(comment_author|wp-postpass|w3tc_logged_out|wordpress_logged_in|wptouch_switch_toggle)&amp;quot;) {&#xA;    set $w3tc_rewrite 0;&#xA;}&#xA;if ($http_cookie ~* &amp;quot;(w3tc_preview)&amp;quot;) {&#xA;    set $w3tc_rewrite _preview;&#xA;}&#xA;set $w3tc_enc &amp;quot;&amp;quot;;&#xA;if ($http_accept_encoding ~ gzip) {&#xA;    set $w3tc_enc _gzip;&#xA;}&#xA;if (!-f &amp;quot;$document_root/wp-content/cache/page_enhanced/$http_host/$request_uri/_index$w3tc_rewrite.html$w3tc_enc&amp;quot;) {&#xA;  set $w3tc_rewrite 0;&#xA;}&#xA;if ($w3tc_rewrite = 1) {&#xA;    rewrite .* &amp;quot;/wp-content/cache/page_enhanced/$http_host/$request_uri/_index$w3tc_rewrite.html$w3tc_enc&amp;quot; last;&#xA;}&#xA;# END W3TC Page Cache core&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;span style=&#34;color: #000000; font-family: Simsun; font-size: 32px; font-weight: bold; line-height: normal; text-align: center;&#34;&gt; &lt;/span&gt;&lt;/p&gt;&#xA;</description>
      <pubDate>Fri, 11 Mar 2016 12:20:20 +0000</pubDate>
    </item>
    <item>
      <title>AlphaGo Tech 1 - MCTS</title>
      <link>http://pages.cs.wisc.edu/~rong/~rong/2016/3/10/alphago-intro-mcts.html</link>
      <description>&lt;h5 id=&#34;sorry-this-post-is-still-under-translation-to-english&#34;&gt;Sorry, this post is still under translation to English&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;首先， AlphaGo和李世石之间的对决是不公平的，AlphaGo的逻辑模块只能用于下围棋，相当于李世石用他的人类大脑挑战一个专门训练成只能用于下围棋的大脑。去年10月在英国挑战樊麾的时候AlphaGo的核心数是1200个CPU和170个GPU，而挑战李世石的时候AlphaGo用了1920个CPU。围棋界有个Elo的参数用来评价围棋手，李世石Elo为3532，去年10月的AlphaGo的Elo值为3168，值得注意的是中国棋手柯洁的Elo为3634。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;AlphaGo总体来讲用了Google DeepMind的Policy Network 和 Value Network指引Monte Carlo算法，相当于用深度学习的技术来引导一个高明的搜索。(其实还有一个Fast Rollout用来快速走子，感谢@dlfall的提醒，总体来说是四个部分:决策网络、价值网络、快速走子和蒙特卡洛树搜索)&lt;/p&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;p&gt;&lt;h3&gt;蒙特卡洛树搜索&lt;/h3&gt;&#xA;蒙特卡洛树搜索(Monte Carlo Tree Search)，是一种人工智能领域的求最优决策的方法，经常由于机器博弈领域，其实可以用于&amp;lt;状态—行动&amp;gt;关系的任何领域作决策。MCTS的过程如下图：(图源维基百科)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/dOneKOg.png&#34; alt=&#34;&amp;quot;MCTS ENG&amp;quot;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Selection： 从Root开始递归选择最优子节点，直到选到叶节点&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Expansion：如果选的最后的叶节点不会导致游戏终止，就创建更多的叶节点(一个或多个)，然后选择其中的一个叶节点&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Simulation：从Expansion选择的那个叶节点开始模拟游戏(没有玩家参与)，直到游戏结束，查看结果。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Backpropagation: 从Simulation的结果来更新当前各个节点的权值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;蒙特卡洛其实就是基于随机的搜索搭配高效的剪枝，把所有结果模拟一遍，所以需要的计算量非常大。蒙特卡洛这个词就是用来指随机的，特点就是它的第一个字：蒙特卡洛做题法 :) &lt;del&gt;蒙特卡洛把妹法&lt;/del&gt; :)&#xA;&lt;h3&gt;节点的选择&lt;/h3&gt;&#xA;然而Monte Carlo不能直接用于围棋，或者说直接用于围棋需要大量的计算能力并且会浪费大部分。早在几年前Mogo，一个机器围棋程序，用了树形UCB搜索+Monte Carlo，UCT：Upper Confidence Bounds for Trees&lt;/p&gt;&#xA;&#xA;&lt;p&gt;UCB是Upper Confidence Bounds，用来对节点估值，UCB公式&#xA;&lt;img src=&#34;http://i.imgur.com/maupECi.png&#34; alt=&#34;&#34; /&gt;&#xA;Wi是第i步后赢的次数，Ni是第i步后模拟的次数，C是个可调整常量，我一般取0.44，听说正常取根号2。t是总模拟次数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;UCT就是Monte Carlo + UCB，就算蒙特卡洛的一个Mod。UCT具有通用性，稍加修改就可以用于各种博弈游戏上。&#xA;&lt;h3&gt;搜索速度&lt;/h3&gt;&#xA;蒙特卡洛会执行相当多次迭代才能收敛到一个较优解，而围棋的搜索深度可能比象棋高百万倍，所以Google DeepMind采用了Policy Network和Value Network来引导蒙特卡洛树搜索，已达到搜索的高度优化。不用人工智能算法的优化还有&lt;em&gt;快速行动价值估算&lt;/em&gt;等&#xA;&lt;h3&gt;AlphaGo局限&lt;/h3&gt;&#xA;&lt;h6&gt;攻破阿尔法狗：AlphaGo的搜索深度在刚开局时的时候是最大的，过半局之后搜索量就大大减少，所以想要打败AlphaGo，除了首先要有世界级的水平之外，在前半句就要努力占到绝对的优势，一旦前半局打得疲软，后半场越往后下落子点就越少，AlphaGo就是无敌的！&lt;/h6&gt;&#xA;AlphaGo用了Deep Learning + Monte Carlo Tree Search就决定了它只能用于“状态-行动”估值和最优策略，从本质上讲就是一个专门下围棋的机器。那么为什么很多人已经在考虑人工智能替代人类然后准备失业了呢？？？&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;h3&gt;Demo&lt;/h3&gt;&#xA;&lt;h6&gt;这是我做的UCT围棋DEMO。首先申明我我一点都不会下围棋，但是通过UCT我可以写出和普通的围棋手一样水准的机器棋手。看上去机器打的还可以 :) (图挂了。。)&lt;/h6&gt;&#xA;&lt;img class=&#34;alignnone size-full wp-image-1155&#34; src=&#34;http://etasry.ml/wp-content/uploads/2016/03/betago.png&#34; alt=&#34;betago&#34; width=&#34;1366&#34; height=&#34;768&#34; /&gt; &lt;img class=&#34;alignnone size-full wp-image-1156&#34; src=&#34;http://etasry.ml/wp-content/uploads/2016/03/betago2.png&#34; alt=&#34;betago2&#34; width=&#34;735&#34; height=&#34;735&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当然，光有蒙特卡洛做不了AlphaGo那么强大的围棋机器，搭配UCT也只能打打普通围棋选手。如果要做AlphaGo，你需要类似Policy Network 和Value Network的深度学习算法，并且有大量的计算能力(像Google那样不缺钱的那种)。&lt;/p&gt;&#xA;</description>
      <pubDate>Thu, 10 Mar 2016 12:20:20 +0000</pubDate>
    </item>
    <item>
      <title>Simple CNNs</title>
      <link>http://pages.cs.wisc.edu/~rong/~rong/2015/1/22/simple-cnn.html</link>
      <description>&lt;h5 id=&#34;a-simple-implementation-of-convolutional-neural-networks&#34;&gt;A simple implementation of Convolutional Neural Networks&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace CNN{&#xA;    vector split(string&amp;amp; str,const char* c)&#xA;    {&#xA;        char *cstr, *p;&#xA;        vector res;&#xA;        cstr = new char[str.size()+1];&#xA;        strcpy(cstr,str.c_str());&#xA;        p = strtok(cstr,c);&#xA;        while(p!=NULL)&#xA;        {&#xA;            res.push_back((double)atof(p) );&#xA;            p = strtok(NULL,c);&#xA;        }&#xA;&#xA;        return res;&#xA;    }&#xA;&#xA;    double sigmoid(double z){&#xA;        return 1.0/(1.0 + pow(e,-z));&#xA;    }&#xA;&#xA;}&#xA;&#xA;vector* pool(vector&amp;lt;vector&amp;lt;vector &amp;gt; &amp;gt; *originOutput,const int sampleRateX,const int sampleRateY){&#xA;    vector *pooledData = new vector(originOutput-&amp;gt;size());&#xA;    for (int i = 0; i &amp;lt; originOutput-&amp;gt;size(); i++) {&#xA;        Patch *layerOutput = new Patch();&#xA;        for (int j = 0; j &amp;lt; (*originOutput)[i].size();j += sampleRateX ) {&#xA;            vector *oneRow = new vector();&#xA;            for (int k = 0; k &amp;lt; (*originOutput)[i][j].size(); k += sampleRateY ) {&#xA;                double max = 0.0;&#xA;                for (int m = 0; m &amp;lt; sampleRateX; m++) {&#xA;                    for (int n = 0; n &amp;lt; sampleRateY; n++) {&#xA;&#xA;                        if (max &amp;lt; (*originOutput)[i][j + m][k + n]) {&#xA;                            max = (*originOutput)[i][j + m][k + n];&#xA;                        }&#xA;                    }&#xA;                }&#xA;                oneRow-&amp;gt;push_back(max);&#xA;            }&#xA;            layerOutput-&amp;gt;push_back((*oneRow));&#xA;        }&#xA;        (*pooledData)[i] = (*layerOutput);&#xA;    }&#xA;    originOutput-&amp;gt;clear();&#xA;    originOutput = new vector(*pooledData);&#xA;    return originOutput;&#xA;}&#xA;&#xA;void getParas(string filepPath){&#xA;    ifstream ifs;&#xA;&#xA;    try {&#xA;        ifs.open((filepPath).c_str());&#xA;&#xA;        string str;&#xA;        while (!ifs.eof()) {&#xA;            //get w1&#xA;            for (int i = 0; i &amp;lt; conv_hiddenNodes; i++ ) {&#xA;                getline(ifs, str);&#xA;                w1-&amp;gt;push_back(CNN::split(str,&amp;quot;,&amp;quot;));&#xA;            }&#xA;            cout&amp;lt;size()&amp;lt;&amp;lt;endl;&#xA;            //get b1&#xA;            getline(ifs, str);&#xA;            *b1 = CNN::split(str,&amp;quot;,&amp;quot;);&#xA;            cout&amp;lt;size()&amp;lt;&amp;lt;endl;&#xA;            //get means&#xA;            getline(ifs, str);&#xA;            *means = CNN::split(str,&amp;quot;,&amp;quot;);&#xA;            cout&amp;lt;size()&amp;lt;&amp;lt;endl;&#xA;&#xA;            //get stds&#xA;            getline(ifs, str);&#xA;            *stds = CNN::split(str, &amp;quot;,&amp;quot;);&#xA;            cout&amp;lt;size()&amp;lt;&amp;lt;endl;&#xA;            break;&#xA;        }&#xA;&#xA;&#xA;        ifs.close();&#xA;    } catch (ifstream::failure e) {&#xA;        cout&amp;lt;&amp;lt;&amp;quot;Exception opening/reading/closing filen&amp;quot;;&#xA;    }&#xA;&#xA;&#xA;}&#xA;&#xA;vector* vetorized(Patch *patch){&#xA;    vector *res = new vector();&#xA;    for (int i = 0; i &amp;lt; patch-&amp;gt;size(); i++) {&#xA;        for (int j = 0; j &amp;lt; (*patch)[i].size(); j++) {&#xA;            res-&amp;gt;push_back((*patch)[i][j]);&#xA;        }&#xA;    }&#xA;    return res;&#xA;}&#xA;&#xA;&#xA;&#xA;void preprocess(vector *vec_pat){&#xA;    for (int i = 0; i &amp;lt; vec_pat-&amp;gt;size() ; i++) {&#xA;        (*vec_pat)[i] -= (*means)[i];&#xA;        (*vec_pat)[i] /= (*stds)[i];&#xA;&#xA;    }&#xA;}&#xA;&#xA;vector *forward2Middle(Patch *patch){&#xA;    vector *res = new vector();&#xA;    vector *patch_vec = vetorized(patch);&#xA;    preprocess(patch_vec);&#xA;&#xA;    for (int i = 0; i &amp;lt; conv_hiddenNodes ; i ++) {&#xA;        double h = 0.0;&#xA;        for (int j = 0; j &amp;lt; inputNodes; j++) {&#xA;            h += (*patch_vec)[j] * (*w1)[i][j];&#xA;        }&#xA;        h += (*b1)[i];&#xA;        h = CNN::sigmoid(h);&#xA;&#xA;        res-&amp;gt;push_back(h);&#xA;    }&#xA;&#xA;    return res;&#xA;}&#xA;&#xA;&#xA;vector* forward(vector&amp;lt;vector &amp;gt; *patches){&#xA;    int patchesSizeX = (int)patches-&amp;gt;size();&#xA;    int patchesSizeY = (int)(*patches)[0].size();&#xA;    vector *middleLayerOutput  = new vector(conv_hiddenNodes,vector&amp;lt;vector &amp;gt;(patchesSizeX,vector(patchesSizeY)));&#xA;    for (int i = 0; i &amp;lt; patchesSizeX; i++) {&#xA;        for (int j = 0; j &amp;lt; patchesSizeY; j++) {&#xA;            vector *res =  forward2Middle(&amp;amp;(*patches)[i][j]);&#xA;            for (int k = 0; k &amp;lt; res-&amp;gt;size(); k++) {&#xA;                (*middleLayerOutput)[k][i][j] = (*res)[k];&#xA;            }&#xA;        }&#xA;    }&#xA;    return middleLayerOutput;&#xA;}&#xA;&#xA;string stringlized(const vector&amp;lt;vector&amp;lt;vector &amp;gt; &amp;gt; *pooledOutput){&#xA;    stringstream ss;&#xA;&#xA;    for (int i = 0; i &amp;lt; pooledOutput-&amp;gt;size(); i++) {&#xA;        for (int j = 0; j &amp;lt; (*pooledOutput)[i].size(); j++) {&#xA;            for (int k = 0; k &amp;lt; (*pooledOutput)[i][j].size(); k++) {&#xA;                ss&amp;lt;&amp;lt;&amp;quot;,&amp;quot;&amp;lt;&amp;lt; (*pooledOutput)[i][j][k];&#xA;            }&#xA;        }&#xA;    }&#xA;    return ss.str();&#xA;}&#xA;string int2str(const int value){&#xA;    string str;&#xA;&#xA;    return str;&#xA;&#xA;void savetoDisk(const vector&amp;lt;vector&amp;lt;vector &amp;gt; &amp;gt; *pooledOutput,string filePath,bool isTrain,int sampleId = 0,int ylabel = -1){&#xA;    ofstream fs;&#xA;    try {&#xA;&#xA;        if (isTrain) {&#xA;            if (!trainFirstFlag) {&#xA;                fs.open(filePath.c_str(),ios::app|ios::out);&#xA;            }else{&#xA;                fs.open(filePath.c_str(),ios::ate|ios::out);&#xA;                trainFirstFlag = false;&#xA;                fs&amp;lt;&amp;lt;&amp;quot;Id,label,value&amp;quot;&amp;lt;&amp;lt;endl;&#xA;&#xA;            }&#xA;            stringstream ss;&#xA;&#xA;            ss &amp;lt;&amp;lt; sampleId&amp;lt;&amp;lt;&amp;quot;,&amp;quot;&amp;lt;&amp;lt;ylabel;&#xA;            string str = ss.str();&#xA;&#xA;            str += stringlized(pooledOutput);&#xA;            fs&amp;lt;&amp;lt;str&amp;lt;&amp;lt;endl;&#xA;&#xA;        }else{&#xA;            if (!testFirstFlag) {&#xA;                fs.open(filePath.c_str(),ios::app|ios::out);&#xA;            }else{&#xA;                fs.open(filePath.c_str(),ios::ate|ios::out);&#xA;                fs&amp;lt;&amp;lt;&amp;quot;Id,value&amp;quot;&amp;lt;&amp;lt;endl;&#xA;                testFirstFlag = false;&#xA;            }&#xA;            stringstream ss;&#xA;            ss &amp;lt;&amp;lt; sampleId;&#xA;            string str = ss.str();&#xA;            str += stringlized(pooledOutput);&#xA;            fs&amp;lt;&amp;lt;str&amp;lt;&amp;lt;endl;&#xA;&#xA;        }&#xA;        fs.close();&#xA;&#xA;    } catch (fstream::failure err) {&#xA;        cout&amp;lt;&amp;lt;&amp;quot;Cannot open output file!&amp;quot;&amp;lt;&amp;lt;endl;&#xA;    }&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;vector&amp;lt;vector &amp;gt;* transfer2Twodimention(const vector *rowVec ,const int first_dimension){&#xA;    vector&amp;lt;vector &amp;gt; *res = new vector&amp;lt;vector &amp;gt;(first_dimension);&#xA;    int cols = (int)rowVec-&amp;gt;size() / first_dimension;&#xA;&#xA;    for (int i = 0 ; i &amp;lt; first_dimension; i++) {&#xA;        for (int j = 0; j &amp;lt; cols; j++) {&#xA;            (*res)[i].push_back( (*rowVec)[i * cols + j]);&#xA;        }&#xA;    }&#xA;&#xA;    return res;&#xA;&#xA;}&#xA;&#xA;&#xA;vector&amp;lt;vector &amp;gt;* getPatches(Image *image,int patchX,int patchY){&#xA;    int patchesX = ((int)image-&amp;gt;size() - patchX +1)  ;&#xA;    int patchesY = ((int)(*image)[0].size() - patchY  + 1);&#xA;&#xA;    vector&amp;lt; vector &amp;gt; *patches = new vector&amp;lt;vector &amp;gt;(patchesX,vector(patchesY));&#xA;&#xA;    for (int i = 0; i&amp;lt; patchesX; i++) {&#xA;        Patch apatch = Patch(patchX);&#xA;        for (int j = 0; j &amp;lt; patchesY; j++) {&#xA;            for (int k = 0; k &amp;lt; patchX; k++) {&#xA;                for (int m = 0; m &amp;lt; patchY; m++) {&#xA;                    apatch[k].push_back( (*image)[i + k][ j + m]);&#xA;                }&#xA;            }&#xA;            (*patches)[i][j] = apatch;&#xA;        }&#xA;    }&#xA;    return patches;&#xA;&#xA;}&#xA;&#xA;&#xA;void convol( FileReader* fileReader,const int patchSizeX,const int patchSizeY,const int middleNodes){&#xA;    conv_hiddenNodes = middleNodes;&#xA;    inputNodes = patchSizeX * patchSizeY;&#xA;    string filePath = &amp;quot;sparsePara.csv&amp;quot;;&#xA;    string trainPath = &amp;quot;train.csv&amp;quot;;&#xA;    string testPath = &amp;quot;test.csv&amp;quot;;&#xA;&#xA;    getParas(filePath);&#xA;&#xA;    const vector&amp;lt;vector &amp;gt; *trainX = (fileReader-&amp;gt;getTrainX());&#xA;    const vector&amp;lt;vector &amp;gt; *trainY = fileReader -&amp;gt; getTrainY();&#xA;    const vector&amp;lt;vector &amp;gt; *testID = fileReader-&amp;gt;getTestID();&#xA;&#xA;    for (int i = 0; i &amp;lt; trainX-&amp;gt;size(); i++) {&#xA;        Image *image = transfer2Twodimention(&amp;amp;(*trainX)[i], sizeX);&#xA;&#xA;        vector&amp;lt;vector &amp;gt; *patches;&#xA;        patches = getPatches(image, patchSizeX, patchSizeY);&#xA;&#xA;        vector *middleOutput = forward(patches);&#xA;&#xA;        middleOutput = pool(middleOutput, samRateX, samRateY);     // now middleOutput saves the pooled output&#xA;        int y = int((*trainY)[i][0]);&#xA;        savetoDisk(middleOutput, trainPath, true,0,y);&#xA;        delete patches;&#xA;        delete middleOutput;&#xA;        cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl;&#xA;     }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
      <pubDate>Thu, 22 Jan 2015 12:20:20 +0000</pubDate>
    </item>
  </channel>
</rss>